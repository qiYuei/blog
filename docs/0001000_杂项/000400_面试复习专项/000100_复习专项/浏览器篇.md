## 1. 浏览器缓存机制

缓存行为可分为 **强缓存 、协商缓存 、启发式缓存**。

1. 强缓存: 不向服务器进行请求,直接读取缓存状态码为 `200`
2. 协商缓存: 向服务器发送请求,服务器根据请求头中的相关字段来判断是否命中缓存,如果命中缓存,则返回 `304` 状态码,否则返 回
   `200` 状态码
3. 启发式缓存: 浏览器根据一些规则来判断是否命中缓存

---

### 启发式缓存

启发式缓存是依赖浏览器自身的规则来判断何时请求资源以及何时缓存资源，也就是说它不需要与服务器进行通信。

::: warning
因为不需要与服务器进行通信，所以它无法知道服务器的最新状态，所以有的时候可能会造成请求了最新资源，但是浏览器还是读取了缓存。
:::

资源相应头中没有出现 `Expire` 和 `cache-control:max-age` 字段且没有出现 `no-store` 的情况下并且有设置 `Last-Modified`,浏览器才会启用 **启发式缓存算法**。但是这个算法的缓存时间因浏览器而异，比如会将响应头中的 `Date` 字段减去 `Last-Modified` 字段的 `10%` 来计算缓存时间。

---

### 协商缓存

协商缓存发生在通信双方三次握手之后,依靠 `Last-Modified/If-Modified-Since`,`Etag/If-None-Match`等标识来确定是否命中协商缓存，如果命中则返回 `304` 状态码,否则返回 `200` 状态码。

其中 `Etag` 是对文件内容的一次 `hash` 运算,`Last-Modified` 则是文件的最后修改时间。

所以 `Last-Modified` 比 `Etag` 更加高效但是 `Etag` 更加准确。

::: warning
如果请求头中 `Last-Modified` 和 `Etag` 都有值,那么服务器会优先选择 `Etag` 来进行缓存判断。
:::

<el-table :data="tableData">
 <el-table-column prop="field" label="字段"  />
 <el-table-column prop="header" label="Header类型" />
 <el-table-column prop="http" label="协议版本" />
</el-table>

<script setup>
import {ref} from 'vue'

const tableData = ref([
  {field:'Last-Modified',header:'Response',http:'http1.0',},
  {field:'IF-Modified-Since',header:'Request',http:'http1.0',},
  {field:'Etag',header:'Response',http:'http1.1',},
  {field:'If-None-Match',header:'Request',http:'http1.1',}
])

const table2 = ref([
  {field:'max-age',desc:'是一个相对时间表示多少毫秒后过期'},
  {field:'no-store',desc:'不使用任何缓存'},
  {field:'no-cache',desc:'不使用强缓存但是必须使用协商缓存'},
  {field:'public',desc:'表示这个资源可以被代理服务器缓存和客户端缓存'},
  {field:'private',desc:'表示这个资源只能被客户端缓存'}

])
</script>

---

### 启发式缓存和协商缓存区别

todo

---

### 强缓存

强缓存在 `http1.0` 中是靠 `Expire` 字段实现，但是由于服务器时间和客户端时间不一致的情况下所以在 `http1.1` 中引入了 `Cache-Control` 字段。

`Cache-Control` 可以组合成多种指令，指令间由 `,` 分隔

```
// eg：
Cache-Control: max-age:3600, s-maxage=3600, public
Cache-Control: no-cache
```

<el-table :data="table2">
<el-table-column prop="field" label="字段"  />
<el-table-column prop="desc" label="描述" />
</el-table>

---

### 缓存位置

- `Service Worker`: 运行在浏览器背后的线程、无法直接访问 `Dom` 但是可以作为 `离线缓存`、`消息推送` 、`网络代理`等用途。协议必须是 `https`
- `Memory Cache` : 缓存在内存中
- `Disk Cache` : 缓存在硬盘中
- `Push Cache` : `http2.0` 的主动推动

::: warning
http2.0 中的主动推送功能在 Chrome106 版本后被禁用
:::

浏览器会根据资源的大小、访问频率以及其他因素来决定将资源存储在内存缓存还是磁盘缓存中。通常，对于较小、频繁访问的资源，浏览器更倾向于将其存储在内存缓存中，而对于较大、不经常访问的资源，浏览器可能选择存储在磁盘缓存中。

---

### 缓存完整过程

浏览器第一次加载资源，服务器返回 `200`，浏览器将资源文件从服务器上请求下载下来，并把 `response header` 及该请求的返回时间一并缓存；

下一次加载资源时，先比较当前时间和上一次返回 `200` 时的时间差，如果没有超过 `Cache-control` 设置的 `max-age`，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持 HTTP1.1，则用 expires 判断是否过期）；如果时间过期，则向服务器发送 `header` 带有 `If-None-Match` 和 `If-Modified-Since` 的请求

服务器收到请求后，优先根据 `Etag` 的值判断被请求的文件有没有做修改，`Etag` 值一致则没有修改，命中协商缓存，返回 `304`；如果不一致则有改动，直接返回新的资源文件带上新的 `Etag` 值并返回 `200`；

如果服务器收到的请求没有 `Etag` 值，则将 `If-Modified-Since` 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 `304`；不一致则返回新的 `Last-Modified` 和文件并返回 `200`；

## 2. 浏览器渲染机制

1. 浏览器会根据 `HTML`内容从上到下解析创建 `DOM Tree`
2. 构建 `CSS` 树，当解析遇到外部样式时会异步下载，并下载完后解析成 `CSS Tree`
   需要注意的是，解析过程中遇到图片、视频等资源都会异步下载，但是遇到 `script` 且没有 `defer/async` 时则会停止解析 `DOM` 等 `script` 下载完并执行完后再继续解析
3. 合并 `DOM Tree` 和 `CSS Tree` 构建 `Render Tree`
4. 布局、将 `Render Tree` 上的计算每一个 `DOM` 节点在屏幕上的位置
5. 绘制，这一步包括很多
   - 构建图层树，将 `Render Tree` 上的节点根据 `CSS` 属性(**zIndex,合成图层**等)进行分层，并按照图层的顺序进行绘制
   - 分块，将图层分割成一个个指令块，并将按照顺序组成绘制列表提交到合成线程中。
   - 光栅化，合成现成中将图层分成图块，进去光栅化线程池中转换成位图
     - 注意因为用户大部分关注视口部分，所以靠近视口部分的图层会优先被光栅化
   - 显示,光栅化完毕后则提交给浏览器进程显示到屏幕上

## 3. 浏览器资源解析机制

## 4. 浏览器安全

## 5. 浏览器性能优化

## 6. 跨域

## 7. 浏览器存储

## 8. 浏览器事件机制

## 9. 浏览器路由
