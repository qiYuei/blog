## Vue 系列

### 为什么用 Proxy 代替 defineProperty

1. `Proxy` 可以直接监听数组长度的变化、对象属性的添加、删除等。对于数组来说 `Proxy` 比 `defineProperty` 性能好
2. `Proxy` 是对整个对象进行代理,而 `defineProperty` 是对属性进行监听，在`数据量大且嵌套深`的数据中会有性能问题
3. `Proxy` 可以对 `Map/Set/WeakMap/WeakSet` 等数据结构进行劫持
4. `Proxy` 可以进行 `懒代理`,在没有用到的属性不添加 `observe` 劫持
5. `Proxy` 可以直接监听数组的变化

### Vue 组件挂载流程

- `Vue2`:
  1. 创建流程: 在创建元素时会调用 `patch` 方法，传入`oldvnode` 和 `vnode`。但是此时的 `oldvnode` 是`null`,所以就会走 `createEle` 就会去尝试看创建的元素是否为 **组件**否则就走创建普通节点的过程。`createComponent`会去执行 `init` 这个 `hook` ,在这个 `hook` 中会**继承**父组件原型链的方法，并实例化一个新组件。然后调用新组件的 `$mount` 方法挂载组件。这个 `$mount` 的方法是将组件转化成**真实节点**的过程,其中会调用 `mountComponent`创建 `watcher` 实例,创建组件更新流程。
  ```js
  function mountedComponent(vm, el) {
    vm.$el = el;
    callHook(vm, "beforeMount");
    const updateComponent = () => {
      vm._update(vm._render());
    };
    // 创建一个渲染watcher,并在实例化的时候会执行一次 updateComponent 的方法，收集依赖
    // _update  方法会调用 patch 方法，传入 oldvnode 和 vnode 的到真实节点,并插入到dom中
    const watcher = new Watcher(
      vm,
      updateComponent,
      () => {
        //
        callHook(vm, "updated");
      },
      true
    );
    callHook(vm, "Mounted");
  }
  ```
  2. 更新流程: 在实例化渲染 `watcher` 的时候会调用组件的 `render` 方法此时数据的 `Dep` 就会收集这个**渲染实例**，当数据更新时就会将自身 `Dep` 里面的所有 `watcher` 实例都调用 `update` 方法，实际上就是调用上面的 `updateComponent` 方法重新调用 `render` 进行 `patch` 更新真实节点。
- `Vue3`:跟 `Vue2` 的流程类似只不过没有了 `watcher` 的概念而是转换成 `effect` 收集`渲染effect`

### Vue3 做了哪些优化

- 编译时
  1. 静态节点提升，将 静态节点提升至 render 函数之外，减少渲染次数
  2. 增加 `patch flag` 标记，标记处节点中有哪些地方是动态的。
  3. 事件函数缓存
- 运行时
  1. `diff` 算法优化,在对比孩子的过程中，使用 `最长递增子序列` 代替 `双指针暴力比较`
  2. 利用编译时的 `patch flag` ,`diff`时只对特定动态 `attrs` 进行比较；比如只有`class`是动态的那将不会进入 `style/text` 的比较

### Vue2 和 Vue3 对响应式数组处理有何不同

- `Vue2` 中没有直接使用 `defineProperty` 对数组进行拦截(原因是 性能差)
  1. 重写了数组的方法,比如 `push`、`pop`、`shift`、`unshift`、`splice`
  2. 重写后的方法会触发 `dep.notify()` 通知 `watcher` 更新
- `Vue3` 中使用 `Proxy` 对数组的 `长度` 和 `索引`以及对能够`修改数组方法`进行拦截

### 双向绑定原理

`Vue`中实现双向绑定主要体现在 `v-model` 这个指令上。`v-model`是一个语法糖本质上还是对 `value` 和 `input` 事件的监听和处理。但是因为我们绑定的数据已经是响应式的，所以当数据发生变化时，视图会自动更新。

### Vue2 和 Vue3 响应式区别

- `Vue2`: 采用 `Object.defineProperty` 对数据的每一个属性的 `get/set` 进行劫持，在渲染时用到响应式数据会触发这个属性的 `get` 从而将 `渲染watcher` 放入 `Dep` 中。在数据变化的时候触发 `set` 并通知该属性 `Dep` 中每一个 `watcher` 进行 `更新`。 使视图发生变化
- `Vue3`: 采用 `Proxy` 进行数据代理，并引用 `effect` 来保存当前的 `渲染函数`。触发 `get` 是将当前的将当前的 `effect` 与数据建立一个**依赖图谱**。在赋值时通过遍历这个数据的 `依赖图谱` 重新执行`渲染函数`来达到视图更新的目的。

### Vue2 和 Vue3 的 diff 算法区别

1. 在比较孩子时 `Vue2` 使用`双指针双端算法`,`Vue3` 使用`最长递增子序列`减少不必要的`Dom`操作
2. `Vue3` 新增 `patch flag` 标记能够针对性比较动态的属性
3. `Vue3` 只会 `diff` 动态节点

### nextTick 原理

- `Vue2`： 通过降级 `Promise`、`MutationObserve`、`setImmediate`、`setTimeout`实现
- `Vue3`： 通过 `Promise` 实现

### keepAlive 原理

通过缓存组件的 `vnode`实现。并通过 `LRU`算法实现最大缓存数量以及失效

### LRU 算法

原理是最近使用的优先插入到后面，而超出则会从头部删除

```js
function LRU(max = 10) {
  let cache = new Set();

  function push(vnode) {
    pop();
    // 这里有个细节，就是Set中如果新加一个重复元素，会先降旧的删除，再将新元素插入到队尾
    cache.add(vnode);
  }

  function pop() {
    if (cache.size > max) {
      cache.delete(keys.values().next().value);
    }
  }

  return {
    push,
    pop,
  };
}
```

### 讲讲 Teleport

`Teleport` 是一个内置组件也是一个新特性。在 `Vue2` 中我们一般挂载的组件都在组件内。如果想在 `body` 等位置挂载需要做一些额外处理。

```js
const instance = new Com({});
instance.$mount(document.body);
```

它出现后就相当于一个`portal`，可以让我们将组件挂载到任何地方。

### 讲讲 Suspense

`Suspense` 是一个内置组件，它允许我们定义 `异步依赖`，并且可以渲染 `loading` 组件。在请求异步组件的时候由于要发生网络请求可能短暂无响应如果加一个`loading`组件可以提升用户体验。

## React

### 引入 fiber 是什么原因，解决了什么问题

`fiber` 是 `react16` 引入的一种概念。因为在 `react` 中的没法像 `vue` 一样做到 `精确更新`,它是从 `根节点` 开始然后一层层比较下来。在处理`大型组件树` 时由于通过 `递归` 的方式进行这可能会出现一些性能问题 `主线程占中时间过长等`

`fiber` 通过 `链表` 的方式将渲染任务分割成一个个`细小`的任务,并通过自行实现 `requestIdleCallback` 的方式来判断主线程`是否繁忙，避免卡顿`。

有以下好处

1. 增量渲染
2. 优先级调度
3. 可中断与恢复

### setState 是同步还是异步

在 `react18` 之前只有在 `事件函数回调、生命周期(componentShouldUpdate除外)`中 是异步的,其他情况下都是同步的

在 `react18` 之后在使用 `createRoot` 创建的应用都是异步处理
